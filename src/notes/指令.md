# 指令

> Angular 提供了两种内置指令：属性型指令和结构型指令。

## 属性型指令

> 属性型指令用于改变一个 DOM 元素的外观或行为，不会改变 DOM 结构。

### 组件是一种特殊的指令

为了验证这一点，我们来修改一点我们以前<code>app-ng-for</code>组件的代码：

```typescript
// ng-for.component.ts
// 修改组件里selector为属性选择器形式（我们之前说过，这里的值就是一个选择器而已）
@Component({
  selector: '[app-ng-for]',
  // ...
})
```

接下来，我们修改下调用组件的方式：

```typescript
// app.component.html
// 我们将div作为指令的宿主，app-ng-for作为一个属性即可
<div app-ng-for></div>
```

经过上面的改动，发现ng-for组件依然可以正常运行。从而证明了，组件是一种特殊的指令。

### 自定义属性型指令

1. cli在<code>src/directives</code>下自动生成highLight指令（当用户把鼠标悬停在一个元素上时，改变它的背景色）：

``` 
ng g d directives/highlight 
```

来看一下生成的默认代码：

```typescript
// highlight.directive.ts
import { Directive } from '@angular/core';
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor() { }
}
```

可以看出，代码结构跟组件类似，使用了<code>@Directive</code>装饰器，传入的<code>selector</code>的值是属性选择器。并且，在<code>app.module.ts</code>中被自动引入：

```typescript
// app.module.ts
import { HighlightDirective } from './directives/highlight.directive';
...
@NgModule({
  declarations: [
    // ...
    HighlightDirective
  ],
  // ...
})
...
```

2. 使用：

```html
<!-- app.component.html -->
<p appHighlight>Highlight me!</p>
```

使用方式是如此简单，但是，根本没有任何效果啊。接下来，我们开始写正式的指令代码。

3. 实现指令：

首先，我们先分析下步骤：

- 找到我们要操作的DOM元素；

- 给元素添加鼠标移入移出事件；

- 修改传入的任意背景颜色；

首先，我们先来解决前两个问题：

```typescript
import { Directive, ElementRef, HostListener } from '@angular/core';
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(private el: ElementRef) { }
  @HostListener('mouseenter') onMouseEnter() {
    this.highlight('yellow');
  }
  @HostListener('mouseleave') onMouseLeave() {
    this.highlight(null);
  }
  private highlight(color: string) {
    this.el.nativeElement.style.backgroundColor = color;
  }
}
```
![directive1](/Users/macair/Desktop/work-space/angular/hero/src/notes/images/directive1.gif)

> 上面的代码解决了我们前两个问题：
>
> - 构造函数只负责声明要注入的元素 el: ElementRef
>
> - @HostListener 装饰器让你订阅某个属性型指令所在的宿主 DOM 元素的事件

对于第三个问题，我们需要使用输入属性来传值：

```typescript
import { Directive, ElementRef, HostListener, Input } from '@angular/core';
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  @Input() highlightColor: string;
  // ...
  @HostListener('mouseenter') onMouseEnter() {
    this.highlight(this.highlightColor);
  }
  // ...
}
```

```html
<!-- app.component.html -->
<p appHighlight highlightColor="blue">Highlight me!</p>
```

通过上面的代码，我们可以实现我们想要的功能。但是，你是否觉得写两个属性有点麻烦呢？下面我们通过**别名**来解决这个问题：

```typescript
...
export class HighlightDirective {
  @Input('appHighlight') highlightColor: string;
  // ...
}
```

```html
<!-- app.component.html -->
<p appHighlight="blue">Highlight me!</p>
```

以上，我们实现来我们全部需求。

### ngNonBindable

> 使用由模板引擎原生支持的 ngNonBindable 伪指令，可以让 Angular 不对模板中的表达式进行求值。
>
> 如果把 ngNonBindable 应用于某个父元素，就会在它的**所有子元素上禁用插值和任何类型的绑定**比如属性绑定或事件绑定。
>
> 不过，ngNonBindable 仍然允许指令作用于受 ngNonBindable 影响的元素上。

```html
<!-- app.component.html -->
<p ngNonBindable appHighlight="blue">Highlight me!</p>
<p ngNonBindable>这样是不会被求值: {{ 1 + 1 }}</p>
```
页面显示效果：

![directive2](/Users/macair/Desktop/work-space/angular/hero/src/notes/images/directive2.gif)

## 结构型指令

> 结构型指令的职责是 HTML 布局。会改变 DOM 结构，以星号（*）加指令的属性名作为标识

在正式了解结构型指令前，我们需要先了解一点基本知识。
### 星号（*）前缀

> *前面，我们了解过最常见的内置结构指令ng-if、ng-for。他们都是以星号（*）开始，为什么呢？*
>
> *答：星号是一个用来简化更复杂语法的“语法糖”。 从内部实现来说，Angular 把 *ngIf 属性 翻译成一个 <ng-template> 元素 并用它来包裹宿主元素。*

我们来做一个简单的解释：

```html
<!-- app.component.html -->
<div *ngIf="hero" class="name">{{hero.name}}</div>
<!-- 上面的写法展开后就是下面的写法： -->
<ng-template [ngIf]="hero">
  <div class="name">{{hero.name}}</div>
</ng-template>
```

### <ng-template>元素

> <ng-template>是一个 Angular 元素，用来渲染 HTML。 它**永远不会直接显示出来**。 事实上，在渲染视图之前，Angular 会把 <ng-template> 及其内容替换为一个注释。